okoshimaenaga

* データ *
スタック 1
レジスタ 26(a-z) + 2(zr, or)

* レジスタ *
レジスタはa-zの26個とzr, orの合計28個
$をつけて指定すると、そのレジスタに格納された値を取得する
$をつけない場合、a-z, zr, orに対応するレジスタ番号(0-27)を指定する
zrは常に値が0
orは常に値が1
レジスタ番号が必要とされているところでも数値やレジスタの値を入れることもできる
その場合はその値がレジスタ番号として処理される
ただし存在しないレジスタ番号が指定された時は例外によって終了する

* ラベル *
:nameという表記でその行にラベルを設定する
ジャンプ命令等で:nameの形で指定するとその行番号の数値として扱われる
それを利用すれば数値として扱うことも可能

* コメント *
行中で;以降は全てコメントして扱われ無視される。

* 命令 *
v~ 値($レジスタ名、数値、またはレジスタ名(レジスタ番号を返す)、ラベル)
r~ レジスタ番号(レジスタ名、または数値やレジスタの値)
l~ 行番号(ラベル名、その他数値)

- レジスタ操作
> set v1 r1
r1にv1の値を格納する

- 算術演算
v1、v2の値によって演算し、結果をr1に格納する
v1が左辺、v2が右辺

> add v1 v2 r1
> sub v1 v2 r1
> mul v1 v2 r1
> div v1 v2 r1
> pow v1 v2 r1
> mod v1 v2 r1

- 論理演算
v1、v2の値を演算し、その結果を真なら1、偽なら0としてr1に格納する

> and v1 v2 r1
> or  v1 v2 r1
> xor v1 v2 r1

- 比較演算
v1、v2の値を比較しその結果を真なら1、偽なら0としてr1に格納する
v1が左辺、v2を右辺として扱う

> equ v1 v2 r1 ... ==
> neq v1 v2 r1 ... !=
> gtr v1 v2 r1 ... >
> lss v1 v2 r1 ... <
> geq v1 v2 r1 ... >=
> leq v1 v2 r1 ... <=

- 型変換
v1の型を変換し、r1に格納する

> int v1 r1
整数型に変換

> flt v1 r1
浮動小数点型に変換

- スタック関連
> psh v1
v1の値をスタックトップに挿入する

> pop r1
スタックトップの値を取り除き、r1で指定されたレジスタに格納する

> clr
スタックを空にする

> len r1
スタックの長さを取得し、r1で指定されたレジスタに格納する

> cpy
スタックトップの値をコピーしスタックに挿入する

- 制御構文関連
> jmp v1 l1
v1の値が1ならl1の行番号まで移動する

- io関連
> chr v1
v1の値に対応するunicode文字を表示する

> prt v1
スタックトップから数えてv1個の値をunicodeの文字としてプリントする

> gch r1
標準入力からユーザの入力した文字を取得しunicode符号化してr1に格納する
複数文字入力された場合、二文字目以降は無視される
何も入力されない場合、-1が格納される

> gtx r1
標準入力からユーザの入力したテキストを取得しunicode符号化してスタックに挿入する
テキストの末尾から挿入され、スタックトップにはテキストの先頭が来ることになる
また、r1にテキスト長が格納される
何も入力されない場合、-1が挿入され、r1には0が格納される
